---
title: "spatial autocorrelation"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
rm(list=ls())
library(lavaan)
library(semPlot)
library(spdep)
library(ggplot2)
library(gridExtra)
load("results.RData") # 130mb file

#source("../scripts/clean_semplot_functions.R") # script for modified plotting functions
#load("../data/brute_force_models_new_order.RData")

theme_set(theme_bw())
```



# SR spatial autocorrelation
```{r}
# subset shapefile for spatial autocorrelation analysis to regions included in SEM
s1 <- shape
s1 <- s1[s1$LEVEL_3_CO %in% dat_no.na$level3,]

shp <- readRDS("../data/shp_object_fin_analysis.RDS")
# subset to model data
shp <- shp[which(shp$LEVEL_3_CO %in% dat_no.na$level3),]
s1$sr_trans <- sqrt(shp$sr)


coo <- coordinates(s1) # get center of each polygon
S.dist  <-  dnearneigh(coo, 0, 1000, longlat = TRUE) # define search radius. we got decimal degrees, so the number refers to kilometers
# nb <- poly2nb(s1, queen=TRUE) # only neighbors 
s1$LEVEL_3_CO[S.dist[[1]]] # neighboring counties
lw <- nb2listw(S.dist, style="W",zero.policy=T)
MI  <-  moran.mc(s1$sr_trans, lw, nsim=599,zero.policy=T)
plot(MI, las=1)
MI$statistic


# try ape moransI
# add coordinates to data
s1$y <- coo[,1]
s1$x <- coo[,2]
distMat <- as.matrix(dist(cbind(s1$x, s1$y)))
#invert this matrix for weights
distsInv <- 1/distMat
diag(distsInv) <- 0
#distsInv[is.infinite(distsInv)] <- 0 # fix infinite cases
mi_raw <- Moran.I(s1$sr_trans, distsInv)
mi_raw 
# much lower using global distance matrix

MI  <-  moran.mc(s1$sr_trans, mat2listw(distsInv, style = "W"), nsim=599, zero.policy=T)
MI$statistic
# same low value with spdest using global dist matrix
```

## distance classes in raw SR
Autocorrelation is highest for distance band of 1600km, e.g. nearest neighbours.
```{r}
# Kreft & Jetz use for their global analysis distance classes between 0 and 5000km, in ca 100km steps
moran <- data.frame(dist.class = seq(100, 10000, 100),
                    moransI = NA,
                    moransp = NA,
                    moransI_sem = NA,
                    moransp_sem = NA, 
                    avg.n = NA)
for(i in 1:length(moran$dist.class)){
  S.dist  <-  dnearneigh(coo, 0, moran$dist.class[i], longlat = TRUE)
  lw <- nb2listw(S.dist, style="W",zero.policy=T) 
  MI <- moran.mc(s1$sr_trans, lw, nsim=599,zero.policy=T) 
  moran$moransI[i] <- MI$statistic
  moran$moransp[i] <- MI$p.value
  lapply(lw$neighbors, mean)
  moran$avg.n[i] <- median(card(lw$neighbours))
  if(!i%%1)cat(i,"\r")
}

plot(moran$moransI~moran$dist.class, 
     type="p", pch=20,
     col=c("red", "black")[as.numeric(moran$moransp<0.05)+1],
     xlab="Distance class (km)",
     ylab="Moran's I")
moran$dist.class[which.max(moran$moransI)]
```



# Residuals spatial autocorrelation
Uses code from https://github.com/jebyrnes/spatial_correction_lavaan to fix getting residuals 
problem (no latent varaible gives all residuals being zero)
* is a lacSpatialCorrect.R function
* correct residual estimation: residuals_lavaan()
*predict_lavaan()

## get residuals and fitted SEM values
```{r}
source("../scripts/spatial_correction_lavaan-master/predict_lavaan.R")
# Fit a new model with meanstructure=TRUE, required by later functions
c2.fit.p <- sem(c2_new, data = dat_no.na, estimator="MLM", meanstructure=TRUE)

# # get residuals
# # To calculate predicted values for a multivariate regression, just save the matrix of predictor variables and the matrix of regression coefficients, then calculate the predicted values by matrix multiplication and subtract them from the observed values.  For example, if your model is X -> M -> Y, then the outcomes are M and Y, and the predictors are X and M" (https://groups.google.com/g/lavaan/c/ftvD1Nxb4Iw)
# predictors <- c("mrd","soil","sub_trop_mbf","area","mont_gs","tra_m","mat_m","sea_m","tri","pre_m")
# outcomes <- c("sr_trans","mrd","area","sub_trop_mbf")
# X <- as.matrix(dat_no.na[predictors])
# X <- cbind(intercept = 1,  X)
# Y <- as.matrix(dat_no.na[outcomes]) # observed values
# B <- lavInspect(c2.fit.p, "coef")$beta[outcomes, predictors]
# int <- lavInspect(c2.fit.p, "coef")$alpha[outcomes, "intercept"]
# B <- t(cbind(intercept = int, B))
# Y.hat <- X %*% B # regression equation
# E <- Y - Y.hat   # casewise residuals
# E
# 
# # B = estimates from the model, X = data, Y.hat = fitted values
# lm1 <- lm(data=dat_no.na, sr_trans ~ soil + sub_trop_mbf + area + mrd + mont_gs + tra_m + mat_m + sea_m + tri)
# pred <- my.predict_lavaan(c2.fit.p) # when i run this function manually it works...???
# fitted <- my.fitted_lavaan(c2.fit.p)
# 
# plot(fitted$sr_trans[,1], Y.hat[,1])
# plot(lm1$fitted.values, Y.hat[,1]) # lm and manual matrix operation are identical
# plot(fitted$sr_trans[,1], lm1$fitted.values)
# # the fitted values are off already, its not the residuals. is it standardized vs other estimates?
# # fitted are between -1:3, when i go through ma
# pred <- my.predict_lavaan(c2.fit.p)
# plot(pred$sr_trans[,1], lm1$fitted.values)
# # all identical now, ok


resids <- as.data.frame(my.residuals_lavaan(c2.fit.p)) 
# plot(residuals(lm1), resids$sr_trans[,1]) # jupp
# plot(dat_no.na$sr_trans, resids$sr_trans[,1])
# abline(h=0)

rawdata <- data.frame(inspect(c2.fit.p, "data")) # get raw data from the model
names(resids) <- paste0(names(resids),"_residuals")
plot(rawdata$sr_trans, dat_no.na$sr_trans) # check order for attaching level3 ID
resids$level3 <- dat_no.na$level3 # this one is tricky, make sure the order is right

#raw visualization of SR residuals
shp <- merge(shp, resids, by.x="LEVEL_3_CO", by.y="level3", all.x=TRUE) 
shp <- merge(shp, dat_no.na[,c("sr_trans", "level3")], by.x="LEVEL_3_CO", by.y="level3", all.x=TRUE)

# get fitted SR values
fitted_vals <- my.fitted_lavaan(c2.fit.p)
names(fitted_vals) <- paste0(names(fitted_vals),"_fitted")
fitted_vals$level3 <- dat_no.na$level3 
shp <- merge(shp, fitted_vals[,c("sr_trans_fitted", "level3")], by.x="LEVEL_3_CO", by.y="level3", all.x=TRUE)

# plot original vs fitted and residuals
grid.arrange(ncol=2,
ggplot(shp, aes(x=sr_trans, y=sr_trans_fitted, col=abs(lat)))+
  geom_point()+
  geom_abline(slope=1, intercept=0)
,
ggplot(shp, aes(x=sr_trans, y=sr_trans_residuals, col=abs(lat)))+
  geom_point()+
  geom_abline(slope=0, intercept=0)
,
ggplot(shp, aes(x=abs(lat), y=sr_trans, col=sr_trans_residuals))+
  geom_point()+
  geom_smooth(method="lm")
,
ggplot(shp, aes(x=abs(lat), y=sr_trans_residuals, col=sr_trans))+
  geom_point()+
  geom_smooth(method="lm")
)

(SR_resid_plot <- ggplot(shp) + 
  geom_sf(aes(fill = sr_trans_residuals), lwd=0.1) + 
  scale_fill_viridis_c(option = "plasma", "Residuals")+ 
#  scale_color_discrete(aes(as.numeric(pvalue<0.05)))+
  theme_void()+
  theme(legend.position = "bottom"))

```



## SR residuals spatial autocorrelation
```{r}
# get spatial autocorrelation for SEM residuals. resids are not in the same order as S1
s1 <- merge(s1, resids[,c("sr_trans_residuals", "level3")], 
            by.x="LEVEL_3_CO", by.y="level3", all.x=TRUE)

# Weihgted distance matrix
coo <- coordinates(s1) # get center of each polygon
distMat <- as.matrix(dist(coo))
#invert this matrix for weights
distsInv <- 1/distMat
diag(distsInv) <- 0
MI  <-  moran.mc(s1$sr_trans_residuals, mat2listw(distsInv, style = "B"), nsim=599, zero.policy=T)
library(ape)
MI.ape  <-  Moran.I(s1$sr_trans_residuals[,1], distsInv)
# chosing weight function: tested B, W, C, U, minmax, S. https://mgimond.github.io/Spatial/spatial-autocorrelation-in-r.html mentions B to be the more robust version. give a weight of 1 if two zones are neighbors, and 0 otherwise, though the definition of 'neighbors' can vary
MI$statistic
MI.ape$observed


# Distance band
S.dist  <-  dnearneigh(coo, 0, 1000, longlat = TRUE) # define search radius. we got decimal degrees, so the number refers to kilometers
# nb <- poly2nb(s1, queen=TRUE) # only neighbors 
#s1$LEVEL_3_CO[S.dist[[1]]] # neighboring counties
lw <- nb2listw(S.dist, style="B",zero.policy=T)
MI.sr.resid  <-  moran.mc(s1$sr_trans_residuals, lw, nsim=599,zero.policy=T)
plot(MI, las=1)
MI$statistic
# comparable to SR raw spatial autocorrelation


for(i in 1:length(moran$dist.class)){
  S.dist  <-  dnearneigh(coo, 0, moran$dist.class[i], longlat = TRUE) # a matrix will all "neighbors" within distance
  lw <- nb2listw(S.dist, style="W", zero.policy=T) 
  MI <- moran.mc(s1$sr_trans_residuals, lw, nsim=599,zero.policy=T) 
  moran$moransI_sem[i] <- MI$statistic
  moran$moransp_sem[i] <- MI$p.value
  #print(paste(moran$dist.class[i], MI$p.value))
  plot(MI)
  if(!i%%1)cat(i,"\r")
}
# S.dist  <-  dnearneigh(coo, 0, 15000, longlat = TRUE) # a matrix will all "neighbors" within distance
#   lw <- nb2listw(S.dist, style="W", zero.policy=T) 
#   MI <- moran.mc(s1$sr_trans_residuals, lw, nsim=599,zero.policy=T)
#   plot(MI)

# second y axis
coeff <- 370
ggplot(moran, aes(x=dist.class)) +
  geom_line( aes(y=moransI)) + 
  geom_line( aes(y=moransI_sem), col="blue") + 
  scale_x_continuous("Distance class (km)")+
  ylab("Moran's I")#+
  # geom_line( aes(y=avg.n / coeff)) + # Divide by coef to get the same range
  # scale_y_continuous(
  #   # Features of the first axis
  #   name = "Moran's I",
  #   # Add a second axis and specify its features
  #   sec.axis = sec_axis(~.*coeff, name="Median neighbors")
  # )+
  # geom_hline(yintercept=median(card(NB))/coeff, lty=2)


# Neighbors map
# shp <- merge(shp, s1@data[,c("LEVEL_3_CO", "nb")], by="LEVEL_3_CO",all.x=TRUE)
# ggplot(shp) + 
#   geom_sf(aes(fill = factor(nb)), lwd=0.1) + 
#   scale_fill_viridis_d(option = "plasma")+  
#   theme_void()
# 
# plot(moran$moransI~moran$dist.class, 
#      ylim=c(-0.05,0.45),
#      #type="l", 
#      pch=20,
#      cex=moran$avg.n,
#      #col=c("red", "black")[as.numeric(moran$moransp<0.05)+1],
#      xlab="Distance class (km)",
#      ylab="Moran's I")
# lines(moran$moransI_sem~moran$dist.class,
#        col="blue"
#         #col= c("red", "black")[as.numeric(moran$moransp<0.05)+1],
#         #pch=17
#        )
# abline(h=0, col="grey30", lty=2)

```


# MRD SAC
```{r}

s1$mrd <- shp$mrd

moran$moransI.mrd = NA
moran$moransp.mrd = NA
moran$moransI.mrd_sem = NA
moran$moransp.mrd_sem = NA 
moran$avg.n.mrd = NA
for(i in 1:length(moran$dist.class)){
  S.dist  <-  dnearneigh(coo, 0, moran$dist.class[i], longlat = TRUE)
  lw <- nb2listw(S.dist, style="W",zero.policy=T) 
  MI <- moran.mc(s1$mrd, lw, nsim=599,zero.policy=T) 
  moran$moransI.mrd[i] <- MI$statistic
  moran$moransp.mrd[i] <- MI$p.value
  lapply(lw$neighbors, mean)
  moran$avg.n.mrd[i] <- median(card(lw$neighbours))
  if(!i%%1)cat(i,"\r")
}

plot(moran$moransI.mrd~moran$dist.class, 
     type="p", pch=20,
     col=c("red", "black")[as.numeric(moran$moransp.mrd<0.05)+1],
     xlab="Distance class (km)",
     ylab="Moran's I")
moran$dist.class[which.max(moran$moransI.mrd)]
```

## SAC MRD residuals
```{r}
s1 <- merge(s1, resids[,c("mrd_residuals", "level3")], 
            by.x="LEVEL_3_CO", by.y="level3", all.x=TRUE)

# Weihgted distance matrix
coo <- coordinates(s1) # get center of each polygon
distMat <- as.matrix(dist(coo))
#invert this matrix for weights
distsInv <- 1/distMat
diag(distsInv) <- 0
MI.mrd.resid  <-  moran.mc(s1$mrd_residuals[,1], mat2listw(distsInv, style = "B"), nsim=599, zero.policy=T)



for(i in 1:length(moran$dist.class)){
  S.dist  <-  dnearneigh(coo, 0, moran$dist.class[i], longlat = TRUE) # a matrix will all "neighbors" within distance
  lw <- nb2listw(S.dist, style="W", zero.policy=T) 
  MI <- moran.mc(s1$mrd_residuals, lw, nsim=599,zero.policy=T) 
  moran$moransI.mrd_sem[i] <- MI$statistic
  moran$moransp.mrd_sem[i] <- MI$p.value
  #print(paste(moran$dist.class[i], MI$p.value))
  plot(MI)
  if(!i%%1)cat(i,"\r")
}

# second y axis
coeff <- 370
ggplot(moran, aes(x=dist.class)) +
  geom_line( aes(y=moransI.mrd)) + 
  geom_line( aes(y=moransI.mrd_sem), col="blue") + 
  scale_x_continuous("Distance class (km)")+
  ylab("Moran's I")

```


# Plot sem residual morans I
```{r}
library(tidyr)
temp <- pivot_longer(moran, cols = c("moransI_sem", "moransI.mrd_sem"))
ggplot(temp, aes(x=dist.class, y=value, col=name)) +
    geom_line()+
    # geom_line( aes(y=moransI_sem)) + 
  # geom_line( aes(y=moransI.mrd_sem), col="blue") + 
  scale_x_continuous("Distance class (km)")+
  scale_color_discrete("SEM residuals", labels=c("SR", "MRD"))+
  ylab("Moran's I")#+
 # add global weight matrix value
  # geom_hline(yintercept = MI.sr.resid$statistic)+
  # geom_hline(yintercept = MI.mrd.resid$statistic)
ggsave("SAC_sem_residuals.png", width=5, height=, units = "in", dpi = 600)
```


# Correct SAC using Byrrnes function 

```{r}
source("../scripts/spatial_correction_lavaan-master/lavSpatialCorrect.R")
coo <- coordinates(s1) # get center of each polygon
coo.df <- data.frame(y=coo[,1], x=coo[,2], level3=s1$LEVEL_3_CO)
dat_no.na <- merge(dat_no.na, coo.df, all.x=TRUE)
# c2.fit.p.cor <- lavSpatialCorrect(c2.fit.p, dat_no.na$x, dat_no.na$y)
# c2.fit.p.cor 
# # default says there is no spatial autocorrelation in residuals, but the output looks incomplete as well, parameters are missing
# # MANUAL
# resids <- as.data.frame(residuals_lavaan(c2.fit.p))
# distMat <- as.matrix(dist(cbind(dat_no.na$x, dat_no.na$y)))
# distsInv <- 1/distMat
# diag(distsInv) <- 0
# mi.sr <- Moran.I(resids$sr_trans[,1], distsInv)
# mi.sr # says nothing, ok
# n.sr <- nrow(dat_no.na)*(1-mi.sr$observed)/(1+mi.sr$observed)
# sqrt(diag(vcov(c2.fit.p))) # path names fuck this function up

# fit a model without path names to use the function correctly
c2_no_path_names <- "
sr_trans ~ soil + sub_trop_mbf + area + mrd + mont_gs + tra_m + mat_m + sea_m + tri
mrd ~ pre_m + sea_m + tra_m + soil + tri + mat_m + area + sub_trop_mbf
soil ~ area + mont_gs + sub_trop_mbf
sub_trop_mbf ~ pre_m + tra_m + mat_m + area + tri"
c2.fit.p <- sem(c2_no_path_names, data = dat_no.na, estimator="MLM", meanstructure=TRUE)

# correct 
c2.fit.SA <- lavSpatialCorrect_correct(c2.fit.p, dat_no.na$x, dat_no.na$y) # use the function that uses correct residuals
# why does this not work anymore..
c2.fit.SA # alright!
# spatial autocorrelation is now present. the correction happens on the basis of the SA in residuals

# compare to original
res <- rbind(
round(c2.fit.SA$parameters$sr_trans[,c(2:6)],3),
round(c2.fit.SA$parameters$mrd[,c(2:6)],3),
round(c2.fit.SA$parameters$sub_trop_mbf[,c(2:6)],3),
round(c2.fit.SA$parameters$soil[,c(2:6)],3)
)
res <- res[-which(grepl("~~",row.names(res))),]
res <- res[-which(grepl("~1",row.names(res))),]
res$variable <- gsub("~.*", "", row.names(res))
res$predictor <- gsub(".*~", "", row.names(res))
library(writexl)

write_xlsx(res[order(res$variable, abs(res$Estimate), decreasing = T),],"sem_model_coefficients_SAC_correction.xls")

# using distance bands instead of global weighted matrix, make sure the function choses the right band for each regression
# moran$dist.class[which.max(moran$moransI_sem)]
# c2.fit.SA.distbands <- my.lavSpatialCorrect(c2.fit.p, dat_no.na$x, dat_no.na$y, distance = 1000)
# c2.fit.SA.distbands # all p values are the same, but thats a genuine signal (look distance band plot)
# round(c2.fit.SA.distbands$parameters$sr_trans[,c(2:6)],3)
# round(c2.fit.SA.distbands$parameters$mrd[,c(2:6)],3)
# round(c2.fit.SA.distbands$parameters$soil[,c(2:6)],3)
# round(c2.fit.SA.distbands$parameters$sub_trop_mbf[,c(2:6)],3)

```

Take the excel sheets, upload to google sheets, then copy paste to google docs.


# original model estimates
```{r}
#write_xlsx(pres2[order(pres2$lhs, abs(pres2$est.std), decreasing = T),],"sem_model_coefficients.xls")
pres2[order(pres2$lhs, abs(pres2$est.std), decreasing = T),]
```



# Model residuals plotted with DR metric, paleoclimate
```{r}
# plot residuals with mean DR
ggplot(shp, aes(x=mdr, y=sr_trans_residuals, col=abs(lat)))+
  geom_point()+
  geom_abline(slope=0, intercept=0)
summary(lm(shp$sr_trans_residuals~shp$mdr))

# plot residuals with paleoclimate
grid.arrange(ncol=2,
ggplot(shp, aes(x=Mio_ano_AP, y=sr_trans_residuals))+
  geom_point()+
  geom_smooth(method="lm")+
  geom_abline(slope=0, intercept=0)
,
ggplot(shp, aes(x=Mio_ano_MAT, y=sr_trans_residuals))+
  geom_point()+
    geom_smooth(method="lm")+
  geom_abline(slope=0, intercept=0)
,
ggplot(shp, aes(x=Plio_ano_AP, y=sr_trans_residuals))+
  geom_point()+
    geom_smooth(method="lm")+
  geom_abline(slope=0, intercept=0)
,
ggplot(shp, aes(x=LGM_ano_MAT, y=sr_trans_residuals))+
  geom_point()+
  scale_x_log10()+
    geom_smooth(method="lm")+
  geom_abline(slope=0, intercept=0)
)
summary(lm(shp$sr_trans_residuals~shp$Mio_ano_AP))
summary(lm(shp$sr_trans_residuals~shp$Plio_ano_AP))
table(is.na(temp$Mio_ano_AP))
table(is.na(temp$Plio_ano_AP))
```